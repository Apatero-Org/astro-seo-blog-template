---
import { getCategories } from '../../lib/data';
import { getPublishedBlogPosts } from '../../lib/posts';
import { getTranslations } from '../../config/i18n';
import { DEFAULT_LANGUAGE, getLanguagePrefix } from '../../config/languages';
import SidebarRelatedPosts from './sidebar/SidebarRelatedPosts.astro';
import SidebarFeaturedArticle from './sidebar/SidebarFeaturedArticle.astro';
import SidebarArticleInfo from './sidebar/SidebarArticleInfo.astro';
import SidebarAuthorInfo from './sidebar/SidebarAuthorInfo.astro';
import SidebarCategories from './sidebar/SidebarCategories.astro';
import SidebarPopularTags from './sidebar/SidebarPopularTags.astro';
import fs from 'fs/promises';
import path from 'path';

export interface Props {
  post?: any; // Optional post data for author info
  readingTime?: number;
  language?: string; // Language for translations
}

const { post, readingTime, language = DEFAULT_LANGUAGE } = Astro.props;
const t = getTranslations(language);
const languagePrefix = getLanguagePrefix(language);

// Get data for sidebar
const categories = await getCategories();
const allPosts = await getPublishedBlogPosts();
const featuredPost = allPosts.find(p => p.data.featured && p.slug !== post?.slug) ||
                     allPosts.find(p => p.slug !== post?.slug) || allPosts[0];

// Get category counts
const categoryCounts = allPosts.reduce((acc, post) => {
  const category = post.data.category;
  acc[category] = (acc[category] || 0) + 1;
  return acc;
}, {});

// Get popular tags with counts
const allPostTags = allPosts.flatMap(post => post.data.tags || []);
const tagCounts = allPostTags.reduce((acc, tag) => {
  acc[tag] = (acc[tag] || 0) + 1;
  return acc;
}, {});
const popularTagsWithCounts = Object.entries(tagCounts)
  .sort((a, b) => b[1] - a[1])
  .slice(0, 10);

// Get author information if post is provided
let authorInfo = null;
if (post) {
  try {
    const authorsPath = path.join(process.cwd(), 'public', 'data', 'authors', 'authors.json');
    const authorsData = JSON.parse(await fs.readFile(authorsPath, 'utf-8'));
    authorInfo = authorsData.authors.find(a => a.id === post.data.author) || null;
  } catch (e) {
    console.error('Error loading author:', e);
  }
}

// Get related posts for sidebar (by shared tags and category)
let relatedPostsForSidebar = [];
if (post) {
  const sameCategoryPosts = allPosts.filter(p =>
    p.data.category === post.data.category && p.slug !== post.slug
  );

  const sameTagsPosts = allPosts.filter(p => {
    const sharedTags = p.data.tags.filter(tag => post.data.tags.includes(tag));
    return sharedTags.length > 0 && p.slug !== post.slug;
  });

  // Combine and deduplicate, prioritizing same category
  const combinedPosts = [...sameCategoryPosts, ...sameTagsPosts];
  const uniquePosts = Array.from(new Map(combinedPosts.map(p => [p.slug, p])).values());
  relatedPostsForSidebar = uniquePosts.slice(0, 5);
}
---

<aside class="space-y-8 lg:sticky lg:top-8 lg:h-fit">
  <!-- Back to All Blogs -->
  <div>
    <a href={`${languagePrefix}/blog`} class="inline-flex items-center gap-2 px-4 py-2 border border-border rounded-full text-text hover:bg-text hover:text-background transition-all text-sm font-medium w-full justify-center">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="19" y1="12" x2="5" y2="12"></line>
        <polyline points="12 19 5 12 12 5"></polyline>
      </svg>
      {t.backToAllBlogs}
    </a>
  </div>

  <SidebarRelatedPosts relatedPosts={relatedPostsForSidebar} translations={t} />
  <SidebarFeaturedArticle featuredPost={featuredPost} translations={t} />
  <SidebarArticleInfo post={post} readingTime={readingTime} translations={t} />
  <SidebarAuthorInfo authorInfo={authorInfo} translations={t} />
  <SidebarCategories categories={categories} categoryCounts={categoryCounts} translations={t} />
  <SidebarPopularTags popularTags={popularTagsWithCounts} translations={t} />
</aside>